<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mxzw.github.io/</id>
    <title>zw</title>
    <updated>2020-09-23T13:42:37.363Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mxzw.github.io/"/>
    <link rel="self" href="https://mxzw.github.io/atom.xml"/>
    <subtitle>你只管努力，剩下的交给未来</subtitle>
    <logo>https://mxzw.github.io/images/avatar.png</logo>
    <icon>https://mxzw.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, zw</rights>
    <entry>
        <title type="html"><![CDATA[LeetCode-初级算法-数组-2：买卖股票的最佳时机II]]></title>
        <id>https://mxzw.github.io/post/leetcode-chu-ji-suan-fa-shu-zu-2mai-mai-gu-piao-de-zui-jia-shi-ji-ii/</id>
        <link href="https://mxzw.github.io/post/leetcode-chu-ji-suan-fa-shu-zu-2mai-mai-gu-piao-de-zui-jia-shi-ji-ii/">
        </link>
        <updated>2020-09-23T09:37:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="买卖股票的最佳时机ii">买卖股票的最佳时机II</h1>
<h2 id="题目描述">题目描述</h2>
<p>给定一个整数数组，判断是否存在重复元素。<br>
如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p>
<h3 id="示例一">示例一</h3>
<pre><code>输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
</code></pre>
<h3 id="示例二">示例二</h3>
<pre><code>输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
</code></pre>
<h3 id="示例三">示例三</h3>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
<h3 id="提示">提示</h3>
<ul>
<li>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</li>
<li>0 &lt;= prices[i] &lt;= 10 ^ 4</li>
</ul>
<pre><code>作者：力扣 (LeetCode)
链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。    
</code></pre>
<p>这次是不算艰难的解题之旅：其实在刚看到这个题的时候，我就被蒙蔽了，一眼扫过去感觉。。。。很难，没有太好的思路，一开始我以为他像求最短距离的问题一样，即求(i,j)=max((i,k)+(k+1,j),(i,j))，其实这些想也能说的通，就想贪心算法一样，找出最佳的那一条路，然后正当我准备将这个想法实例化的时候，我突然发现，哎，这个数组是不能修改的，也不能往前遍历，那么只要向后遍历就行，只要第<strong>i</strong>个数<strong>小于</strong>第<strong>i+1</strong>个数，那么就求他们元素之间的差值，找个中间变量存起来，然后继续相后遍历，所得到的差值之和就是要求的最大利润，想到这里，我觉得是可行的，就写了提交上去，结果，提交成功。哇，真好，这就是提交成功的感觉吗，真好，真不错！！<br>
下面是我写的代码：</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
       int sum = 0;
        for(int i = 0;i&lt;prices.length-1;i++){
            if(prices[i]&lt;=prices[i+1]){
                sum += prices[i+1]-prices[i];
            }
        }
        return sum;
    }
}
</code></pre>
<p>其实我写的还是有一些缺陷的，应该把<strong>i</strong>和<strong>i+1</strong>换成<strong>i-1</strong>和<strong>i</strong>的，这些就更好一些，当然我这样写也可以，我让最后循环退出的条件是<strong>prices.length-1</strong>，这样写也可以，但感觉是不太好的。<br>
然后我就去看了一下，官方题解的做法，官方题解提供了三种方法，第一种是暴力法，就是直接计算所有可能交易组合相对应的利润，然后找出最大值，这个理解是挺好理解的，但是这具体写的话，还真有点难度，然后第二种方法就很奇特了，用了峰谷法，好像就是通过while循环通过**prices[i] &gt;= prices[i + 1]<strong>和</strong>prices[i] &lt;= prices[i + 1]**找到对应的峰点和谷点，然后最大的利润就是每一次找出波峰和波谷的差值之和。这个方法就很独特，很好；而第三种方法就是我这种方法了，很是舒适，我终于能和官方题解的思路一样（虽说是这个题简单把，但毕竟是第一次，还是很开心的），真好。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode-初级算法-数组-4：存在重复元素]]></title>
        <id>https://mxzw.github.io/post/leetcode-chu-ji-suan-fa-shu-zu-4cun-zai-chong-fu-yuan-su/</id>
        <link href="https://mxzw.github.io/post/leetcode-chu-ji-suan-fa-shu-zu-4cun-zai-chong-fu-yuan-su/">
        </link>
        <updated>2020-09-22T09:44:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="存在重复元素"><strong>存在重复元素</strong></h1>
<h2 id="题目描述">题目描述</h2>
<p>给定一个整数数组，判断是否存在重复元素。<br>
如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p>
<h3 id="示例一">示例一</h3>
<pre><code>输入: [1,2,3,1]
输出: true
</code></pre>
<h3 id="示例二">示例二</h3>
<pre><code>输入: [1,2,3,4]
输出: false
</code></pre>
<h3 id="示例三">示例三</h3>
<pre><code>输入: [1,1,1,3,3,4,3,2,4,2]
输出: true
</code></pre>
<pre><code>作者：力扣 (LeetCode)
链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<p>又是一天艰难的解题之路：在我看到这个带有重复元素的数组时，我大脑第一时间浮现双指针（懂得都懂），我首先考虑的是能否用单循环做，题目要求如果找到重复元素的话就返回true值，就说明两个指针都是要动的，所以只能采用双循环，用<strong>i</strong>指向第一个元素，用<strong>j=i+1</strong>来往后遍历数组，并对其元素进行比较，如果<strong>nums[i] == nums[j]</strong>,则返回true，否则返回false；话不多说，看代码。</p>
<pre><code>class Solution {
    public boolean containsDuplicate(int[] nums) {
        if(nums.length==0) return false;
       for (int i = 0; i &lt; nums.length; i++) {
			for (int j = i + 1; j &lt; nums.length; j++) {
				if (nums[i] == nums[j]) {
					return true;
				}
			}
		}
        return false;
    }
}
</code></pre>
<p>但是在leetcode上显示的结果是：<br>
<img src="https://mxzw.github.io//post-images/1600768702167.BMP" alt="" loading="lazy"><br>
我哭了，我还感觉我写的很完美呢，结果给我来这一出，他说是超出时间限制，我就想会不会是双循环时间复杂度是o(n<sup>2</sup>)，太大了，导致测试大数据时，超出时间限制了呢，于是我就思考如何用单循环来完成这个题，还是同样的思想，我用while循环实现了两个指针的移动，引入一个flag来做标记，从而实现题目要求。直接看代码。</p>
<pre><code>class Solution {
    public boolean containsDuplicate(int[] nums) {
		if(nums.length==0) return false;
		int i = 0;
		int j = i + 1;
		boolean flag = false;
		while (i &lt; nums.length &amp;&amp; j &lt; nums.length) {
			if (nums[i] == nums[j]) {
				flag=true;
				return flag;
			}
			else {
				j++;
			}
			if (j == nums.length - 1 &amp;&amp; flag == false) {
				if(nums[i] == nums[j]) {
					flag = true;
					return flag;
				}
				i++;
				j = i + 1;
			}
			
		}
		return flag;
    }
}
</code></pre>
<p>然后leetcode上显示的提交结果为：<br>
<img src="https://mxzw.github.io//post-images/1600769075123.BMP" alt="" loading="lazy"><br>
还是同样的超出时间限制，只不过这次还有最后执行的输入，这个数据太多了，我就只截了一半的图，其实这个时间复杂度还是n<sup>2</sup>，但是当时做的时候只想尝试用单循环做了，没考虑太多。</p>
<p>然后我就又按捺不住了，因为我实在想不出还有什么其他的办法来解这个题，于是我就又看来官方题解。。</p>
<p>官方题解给了3种解决的办法，第一种就是我第一次想的那种，没问题，但是人家也说了，在里面提交会超出时间限制。然后第二种就是排序，是的，排序，先将该数组排序，然后再for循环一下，将<strong>i</strong>和<strong>i+1</strong>个元素做比较，如果相等就返回true。是的，就是这么简单。然后第三种就是通过哈希表来解决，好像是用set方法或map方法来解决，我也没搞太懂，java还未学到那。</p>
<p>这里我用的是第二种方法。代码如下：</p>
<pre><code>class Solution {
    public boolean containsDuplicate(int[] nums) {
        if(nums.length==0) return false;
        Arrays.sort(nums);
        for(int i = 1;i&lt;nums.length;i++){
            if(nums[i]==nums[i-1]){
                return true;
            }
        } 
        return false;
    }
}
</code></pre>
<p>ok，成功通过，不得不说，这官方题解的思路就是好。其实我在看别人写的题解时，有个很奇特的方法，还是第二种的方法，但是在比较时，用的是异或的方法，将排好序的数组中的元素进行异或，如果异或结果为0，则证明是有重复元素的，返回true，如果没有，就返回false。真好，思想真好，我什么时候也能像这些人一样驰骋题库呢。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode-初级算法-数组-1：删除排序数组的重复项]]></title>
        <id>https://mxzw.github.io/post/leetcode-chu-ji-suan-fa-shu-zu-1shan-chu-pai-xu-shu-zu-de-chong-fu-xiang/</id>
        <link href="https://mxzw.github.io/post/leetcode-chu-ji-suan-fa-shu-zu-1shan-chu-pai-xu-shu-zu-de-chong-fu-xiang/">
        </link>
        <updated>2020-09-21T06:46:15.000Z</updated>
        <content type="html"><![CDATA[<p>今天开始刷LeetCode中的面试类型题</p>
<h1 id="删除排序数组中的重复项">删除排序数组中的重复项</h1>
<p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<h2 id="示例1"><strong>示例1：</strong></h2>
<pre><code>给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
</code></pre>
<h2 id="示例2"><strong>示例2：</strong></h2>
<pre><code>给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
</code></pre>
<h2 id="说明"><strong>说明：</strong></h2>
<p>为什么返回数值是整数，但输出的答案是数组呢?<br>
请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br>
你可以想象内部操作如下:</p>
<pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</code></pre>
<pre><code>作者：力扣 (LeetCode)
链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<p>我的艰难解题之路：题目要求是返回删除重复数组元素后的长度，并在运行中不能开辟新的数组空间以及要在“原地”修改删除数组的元素，还要求了空间复杂度为O(1)，由于我对空间复杂度的概念理解的并不是很透彻，因此看到这个O(1)我就认为这个题只能用一个for循环来做，二个for循环是不符合题意的(实际上是可以的)，因此我就用了好几个小时来想如何用一个for循环解这个题，当时我认为采用双指针必须要用两个for循环来表示，这是思维定势了，平常见到的算法大多都是用双循环来表示双指针的，如果我当时反映过来可以用双循环来解题，那这个题就很so easy了，不会花我好几个小时来解这个题了。由于思维的定势，我想了好久挣扎出来的代码一运行是错误的，然后我心态就崩了(本来想着不看网上答案的，但我忍不住了)，我就上网看了看官方题解是怎么写的，然后我心态血崩，这么简单的思路我想了好久，还没想出来，顿时心情就一落千丈，唉，说多了就是泪，我来说说人家官方题解的思路吧；<font color = "red">还是采用双指针，但是只用了一个for循环，，在for循环的外面定义一个指针，让他指向数组的开头a[0]，然后在for循环里面用它定义的变量做指针，开始指向数组的第二个元素a[1]，然后用if语句进行判断，如果a[i]!=a[j];则i++并且a[i]=a[j];然后直到循环结束，返回i+1。</font>看完之后，我只想说：妙啊！！，我怎么就想不到呢，想想自己花了那么多时间都没想出来的题，以为有多难呢，结果被如此轻易的做出来。。。唉，心情复杂！<br>
补充：因为是排序数组，所以重复元素都是相邻的！</p>
<h3 id="下面是代码">下面是代码</h3>
<pre><code>    class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length == 0) 
            return 0;
        int i = 0;
		for (int j = 1; j &lt; nums.length; j++) {
			if(nums[j]!= nums[i]) {
				i++;
				nums[i]=nums[j];
			}
		}
		return i+1;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript——脚本基础]]></title>
        <id>https://mxzw.github.io/post/javascript-jiao-ben-ji-chu/</id>
        <link href="https://mxzw.github.io/post/javascript-jiao-ben-ji-chu/">
        </link>
        <updated>2020-05-14T10:42:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="javascript概述">JavaScript概述</h1>
<ul>
<li>是一种脚本语言，在程序运行中逐行解释（就是逐行运行），而不需要实现编译。</li>
<li>基于对象，能够使用存在的程序对象，但它无法像Java一样完全面向对象。</li>
<li>能够跨平台，JavaScript主要是通过浏览器进行解释执行，和操作系统不发生直接关系，能够运行浏览器软件的地方就可以运行JavaScript。</li>
<li>通过浏览器执行，根据浏览器不同执行可能会有差异 。</li>
</ul>
<h2 id="第一个javascript程序"><strong>第一个JavaScript程序</strong></h2>
<p>直接新建.html文件，然后写下以下代码：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    document.write(&quot;我的第一个JavaScript程序&quot;);
&lt;/script&gt;
</code></pre>
<p>运行效果如图所示：<br>
<img src="https://mxzw.github.io//post-images/1589453815412.PNG" alt="效果展示" loading="lazy"></p>
<h2 id="编写javascript语言的软件"><strong>编写JavaScript语言的软件</strong></h2>
<ul>
<li>记事本</li>
<li>Dreamweaver</li>
<li>Hbuilder</li>
<li>WebStorm</li>
<li>Sublime</li>
</ul>
<h3 id="入门案例">入门案例：</h3>
<pre><code> &lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot; /&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script type=&quot;text/javascript&quot;&gt;
			document.write(&quot;&lt;h1&gt;你要一个人悄悄的努力，然后惊艳所有人!&lt;/h1&gt;&lt;br /&gt;&quot;);
			/*document.write(&quot;&quot;)在当前文件中输出双引号中的内容*/
			var count=0;/*var表示定义一个变量 （variable）*/
			for (var i=0;i&lt;5;i++) {
				document.write(&quot;&lt;b&gt;你一定要加油！！&lt;/b&gt;&lt;br /&gt;&quot;);
			}
		&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;Fighting ! ! !&lt;/h1&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>实际效果如下：<br>
<img src="https://mxzw.github.io//post-images/1589456154092.PNG" alt="效果展示" loading="lazy"></p>
<ul>
<li>var表示定义一个变量 （variable）</li>
<li>document.write(&quot;xxxx&quot;)表示在当前文件中输出双引号中的内容</li>
</ul>
<h3 id="使用变量"><strong>使用变量</strong></h3>
<ul>
<li>JavaScript是采用<strong>弱数据类型</strong>的语言，意味着<strong>声明变量时不需要指定变量的数据类型</strong>，数据在被赋给变量的时候会自动确定数据类型。</li>
<li>在JavaScript中的声明一个变量的语法如下：<br>
var 变量名;</li>
<li>也可以用一条语句声明多个变量：<br>
var 变量名1,变量名2,变量名N;</li>
<li>以下代码是合法的变量声明：<br>
var a1; 或者 var a1 = 10;<br>
var a2,a3; 或者 var a2,a3 = 10;</li>
<li>变量的命名和C语言一样，都是以字母或下划线开头（不能以数字开头），并且区分大小写</li>
<li>例如：</li>
</ul>
<pre><code>    &lt;script&gt;
        var A=&quot;Uppercase  A&quot;;
	     var a=&quot;Lowercase  a&quot;;
         var x=0;
         x = x +10;
         document.write(x);
		document.write(A);
		document.write(&quot;&lt;br&gt;&quot;);
		document.write(a);
     &lt;/script&gt;
</code></pre>
<p><strong>document.write() 使用</strong></p>
<ul>
<li>字符串的输出：不改变双引号内的内容</li>
<li>数字的输出：根据运算符进行运算的结果</li>
<li>字符串与数字连接：字符串 + 数字</li>
<li>数字与字符串连接: 数字 + 字符串<br>
代码如下：</li>
</ul>
<pre><code>    			//字符串的输出：不改变双引号内的内容
			document.write(&quot;1 + 2&quot;);
			document.write(&quot;&lt;br /&gt;&quot;);
			//数字的输出：根据运算符进行运算的结果
			document.write(1 + 2);
			document.write(&quot;&lt;br /&gt;&quot;);
			//字符串与数字连接：字符串 + 数字
			document.write(&quot;1 + 2 = &quot;+ 1 + 2);
			document.write(&quot;&lt;br /&gt;&quot;);
			//数字与字符串连接: 数字 + 字符串
			document.write(1 + 2 + &quot;1 + 2 = &quot;);
			document.write(&quot;&lt;br /&gt;&quot;);
</code></pre>
<p>效果如下：<br>
<img src="https://mxzw.github.io//post-images/1590811049703.PNG" alt="" loading="lazy"><br>
总结： 数字 + 数字 是加法运算；数字+字符串是字符的粘连</p>
<h3 id="基本运算符"><strong>基本运算符</strong></h3>
<p>和C语言相同，<strong>+、-、*、/、%、++、--</strong>，对应相加、相减、相乘、相除、求余、自加1、自减1，但需要注意的是由于JavaScript是弱数据类型，因此 10 / 3 = 3.3333，会自动改变数值类型，和C的强类型数据不一样，两个整数相除，结果仍为整数，小数部分直接舍去。而对于比较运算符，JavaScript显示的是布尔类型的值，即true和false。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法设计——动态规划（一）]]></title>
        <id>https://mxzw.github.io/post/suan-fa-she-ji-dong-tai-gui-hua-yi/</id>
        <link href="https://mxzw.github.io/post/suan-fa-she-ji-dong-tai-gui-hua-yi/">
        </link>
        <updated>2020-04-21T09:49:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-动态规划">一、动态规划</h1>
<h3 id="11简介"><strong>1.1简介</strong></h3>
<ul>
<li>动态规划是运筹学的一个分支，是解决多阶段决策过程优化问题的方法，即最优化原理，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解。</li>
<li>动态规划主要用于求解以时间划分阶段阶段的动态过程的优化问题，但一些与时间无关的静态规划（如线性规划、非线性规划），只有人为的引进时间因素，把它视为多阶段决策过程，也可用动态规划方法方便的求解。</li>
<li>动态规划是考察问题的一种途径，或者求解某类问题的一种方法。</li>
</ul>
<h3 id="12算法总体思想"><strong>1.2算法总体思想</strong></h3>
<p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，再从子问题的解得到原问题的解。但求解出的子问题往往不是相互独立的，再用分治法求解问题时，会发现有些子问题会被重复计算很多次，增加了算法的时间复杂度，增加了程序运行的负担。但动态规划却很好的解决此类出现重复计算额问题；动态规划用一个表来记录所有的已解决的子问题的答案（此处可以理解为创建了一个数组，该数组中存储了用动态规划已解决的问题的数值），具体的动态规划算法虽然多种多样，但是他们具有相同的填表方式。</p>
<h3 id="13动态规划基本步骤"><strong>1.3动态规划基本步骤</strong></h3>
<ol>
<li>找出最优解的性质，并刻划其结构特征</li>
<li>递归地定义最优值</li>
<li>以自底向上的方式计算出最优值</li>
<li>根据计算最优值时得到的信息，构造最优解
<ul>
<li>步骤1-3时动态规划的基本步骤。如果只需要求出最优值的情形，步骤4可以省略</li>
<li>若需要求出问题的一个最优解，则必须执行步骤4，步骤3中记录的信息时构造最优解的基础；</li>
</ul>
</li>
</ol>
<h3 id="14分治递归-动态规划-贪心算法"><strong>1.4分治递归、动态规划、贪心算法</strong></h3>
<table>
    <tr  align="center">
     <th>分治递归</th>
     <th>动态规划</th>
     <th>贪心算法</th>
    </tr>
    <tr>
        <td>
            <ul>
                    <li> 递归与分治策略</li>
                    <li>Top-down</li>
            </ul>
        </td>
                <td>
            <ul>
                    <li> 查表方式</li>
                    <li> 最优子结构</li>
                    <li>Bottom-down</li>
            </ul>
        </td>
                <td>
            <ul>
                    <li>贪心性质</li>
                    <li>Top-down</li>
            </ul>
        </td>
    </tr>
</table>
<h1 id="二-矩阵连乘问题">二、矩阵连乘问题</h1>
<h3 id="21问题描述"><strong>2.1问题描述</strong></h3>
<p>给定n个矩阵{A<sub>1</sub>,A<sub>2</sub>,...,A<sub>n</sub>},其中A<sub>i</sub>与A<sub>i+1</sub>是可乘的，i=1,2,3,...,n-1<br>
如何确定矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积所需要的数乘<strong>次数最少</strong>。<br>
矩阵乘法满足结合律，且矩阵的连乘可以有不同的计算次序。可以通过给矩阵加括号的方式，来确定计算次序。题目要求的是如何通过加括号的方式来使矩阵连乘的次数最少。<br>
例：有四个矩阵A、B、C、D，它们的维数分别是：A=50×10，B=10×40，C=40×30，D=30×5<br>
则它们的连乘积ABCD共有五种完全加括号的方式：<br>
(A((BC)D)) ------&gt; 16000    (A(B(CD))) -------&gt; 10500<br>
((AB)(CD)) ------&gt; 36000    (((AB)C)D) -------&gt;87500<br>
((A(BC))D) ------&gt; 34500<br>
计算次数的方法：AB=50×10×40<br>
则当加括号的方式为(A(B(CD)))时，矩阵连乘的次数最少。</p>
<h3 id="22动态规划解法"><strong>2.2动态规划解法</strong></h3>
<ol>
<li>
<p>分析最优解的结构<br>
将矩阵连乘积A<sub>i</sub>A<sub>i+1</sub>…A<sub>j</sub>简记为A[i:j] ，为了寻找A[i:j]最优的计算次序，设这个计算次序的在矩阵A<sub>k</sub>和A<sub>k+1</sub>之间断开，i≤k≤j，，则其相应完全加括号方式为 (A<sub>i</sub>A<sub>i+1</sub>…A<sub>k</sub>)(A<sub>k+1</sub>A<sub>k+2</sub>…A<sub>j</sub>)。 则计算算A[i:j]的最优次序所包含的计算矩阵子链 A[i:k]和A[k+1:j]的次序也是最优的。</p>
</li>
<li>
<p>建立递归关系<br>
设计算A[i:j]，1≤i≤j≤n，所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n]。取得得k为A[i:j]最优次序断开位置，并记录到表s[i][j]中，即s[i][j] = k。注：m[i][j]实际为子问题最优的解值，保存下来避免重复计算。<br>
<img src="https://mxzw.github.io//post-images/1587535129335.BMP" alt="" loading="lazy"><br>
<font style="color:red;"> 注：图中A[1][1] 指得是A，A[2][4] 指得是BCD，同理，A[3][4]指得是CD。 </font></p>
</li>
<li>
<p>计算最优值<br>
由步骤2可列出计算式如下图：<br>
<img src="https://mxzw.github.io//post-images/1587536495069.BMP" alt="" loading="lazy"><br>
核心代码如下：</p>
<pre><code> void MatrixChain(int *p,int n,int **m,int **s)
 {   //*p 存放矩阵Ai的维数。**m 存放最优值。 **s 存放断开位置。n 为连乘矩阵的数量。
     for(int r = 2; r&lt;=n;r++ )
     {
         for(int i = 1; i&lt;=n-r+1;i++)
         {
             int j = i+r-1;
             m[i][j] = m[i+1][j] + p[i-1]*p[i]*p[j];  // 12、23、34、....。
             s[i][j] = i;
             for(int k=i+1; k&lt;j; k++)
             {
                 int t = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j];
                 if(t&lt;m[i][j])
                 {
                     m[i][j] = t;
                     s[i][j] = k;
                 }
             }
         }
     }
 }
</code></pre>
<p>例题如下：<br>
<img src="https://mxzw.github.io//post-images/1587536562830.BMP" alt="" loading="lazy"></p>
</li>
<li>
<p>构造最优解<br>
按算法计算出的断点矩阵s指示的加括号方式输出计算A[i:j]的 最优先次序。</p>
<pre><code>void Traceback(int i,int j,int **s)
{
    if(i==j) return;
    Traceback(i,s[i][j],s);
    Traceback(s[i][j]+1,j,s);
    cout&lt;&lt;“Multiplay A”&lt;&lt;i&lt;&lt;“,”&lt;&lt;s[i][j];  
    cout&lt;&lt;“and A”&lt;&lt;s[i][j]+1&lt;&lt;“,”&lt;&lt;j&lt;&lt;endl; 
}
</code></pre>
<p>本文大多内容均来自于<a href="https://www.icourse163.org/learn/XMU-1205800806?tid=1450170449#/learn/announce">中国大学MOOC_算法设计与分析_厦门大学_曾华琳</a>课程课件。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML学习日记（五）——div]]></title>
        <id>https://mxzw.github.io/post/html-xue-xi-ri-ji-wu-div/</id>
        <link href="https://mxzw.github.io/post/html-xue-xi-ri-ji-wu-div/">
        </link>
        <updated>2020-04-19T04:18:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-div的定义和用法">一、div的定义和用法</h1>
<p>＜div＞可定义文档中的分区或节。＜div＞标签可以把文档分为独立的、不同的部分。如果用id和class来标记＜div＞，那么该标签的作用会变得更加有效。<br>
＜div＞是一个块级元素，它的内容会自动换行，即浏览器通常会在＜div＞标签前后放置一个换行符；实际上，换行是＜div＞固有的唯一格式表现，可以通过＜div＞的class或id应用额外的样式。<br>
应用class或id作为＜div＞的属性，一般class用于元素组（或是说某一类元素），而id用于标识唯一的元素。</p>
<h1 id="二-div的练习">二、div的练习</h1>
<h3 id="练习一"><strong>练习（一）</strong></h3>
<p>代码如下：<br>
①HTML文档代码：</p>
<pre><code>   &lt;!DOCTYPE html&gt;
   &lt;html&gt;
   &lt;head&gt;
   	&lt;meta charset=&quot;UTF-8&quot;&gt;
   	&lt;title&gt;div的练习&lt;/title&gt;
   	&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;zw-11div练习1.css&quot;/&gt;
   &lt;/head&gt;
   &lt;body&gt;
   	&lt;div id=&quot;first&quot;&gt;
   		first
   	&lt;/div&gt;
   	&lt;div id=&quot;second&quot;&gt;
   		second
   	&lt;/div&gt;
   &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>②CSS文档代码：</p>
<pre><code>
*{
	margin: 0px;  /*代表外边距为0 */
	padding: 0px;   /*代表内边距为0*/
}
/*  * 是通配选择器，设置网页的默认值  */

#first{
	position: absolute;   /*指默认位置为绝对路径*/
	background-color: red;
	width: 200px;
	height: 200px;
	left: 30px;
	top: 50px;
	z-index: 2;
}

#second{
	position: absolute;
	width: 200px;
	height: 200px;
	background-color: green;
	left: 60px;
	top: 100px;
	z-index: 1;
	/*z-index 表示图层的先后   大的在前，小的在后*/
}
</code></pre>
<p>其中CSS文档中，用“*”来表示通配选择器，一般用来设置网页的默认值。（通常都是初始化网页的内外边距），一般用div来进行分层，用z-index来表示div图层的先后。<br>
实际效果如下：<br>
<img src="https://mxzw.github.io//post-images/1587345135137.BMP" alt="" loading="lazy"></p>
<h3 id="练习二"><strong>练习（二）</strong></h3>
<p>代码如下：<br>
①HTML文档代码：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;UTF-8&quot;&gt;
		&lt;title&gt;div的练习&lt;/title&gt;
		&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;zw-12div的练习2.css&quot;/&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div id=&quot;one&quot;&gt;
			
		&lt;/div&gt;
		&lt;div id=&quot;two&quot;&gt;
			today you are very cool!!! 
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>②CSS文档代码：</p>
<pre><code>
*{
	margin: 0px;
	padding: 0px;
}

#one{
	background-color: red;
	width: 300px;
	height: 300px;
	margin-top: 30px; /*距离上外边距30px*/
	margin-left: 30px;/*距离左外边距30px*/
	/*无position表示默认位置为相对位置*/
	float: left;  /*one中内容向左漂浮*/
}

#two{
	background-color: green;
	width: 500px;
	height: 300px;
	margin-top: 40px;
	margin-left: 50px;
	font-size: 30px; /*字体大小*/
	color: red;/*字体颜色*/
	padding-left: 50px;  /*字体距离图层  左内边距50px*/
	padding-top: 50px; /*/*字体距离图层  上内边距50px*/
	box-sizing: border-box; /*使边框不随着 padding属性的改变而改变，
								固定边框的大小*/
	float: left;
}

/*块级元素 会直接占据网页的一行 当位置相对时，
 * 另一个块级元素会在上一个块级元素的下面 而不是左右*/ 
</code></pre>
<p>实际效果如下：<br>
<img src="https://mxzw.github.io//post-images/1587345446454.BMP" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML学习日记（四）——css、超链接状态]]></title>
        <id>https://mxzw.github.io/post/html-xue-xi-ri-ji-si-csschao-lian-jie-zhuang-tai-div/</id>
        <link href="https://mxzw.github.io/post/html-xue-xi-ri-ji-si-csschao-lian-jie-zhuang-tai-div/">
        </link>
        <updated>2020-04-17T00:36:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-css">一、CSS</h1>
<p>前面也提到过，<strong>CSS</strong>是指层叠样式表，它是一个存放样式的样式表，而样式可以定义如何显示HTML元素，且样式通常保存在外部的.css文件中，通过相应的编辑，这个外部样式表就可以让你可以自定义该页面中所有的布局和外观。<br>
样式表允许以多种方式规定样式信息。样式可以规定在单个的HTML元素中、在HTML的头元素中（＜head＞标签）、或在一个外部的CSS文件中。甚至可以在同一个HTML文档内部引用多个外部样式表。<br>
那么，当同一个HTML元素被不止一个样式定义时，会使用哪个样式呢？<br>
一般而言，所有的样式会根据下面的规则层叠于一个新的虚拟样式表中，其第四个拥有最高的优先权。</p>
<ul>
<li>浏览器缺省设置</li>
<li>外部样式表</li>
<li>内部样式表（位于＜head＞标签内部）</li>
<li>内联样式（在HTML元素内部）</li>
</ul>
<p>因此，内联样式（在HTML元素内部）拥有最高的优先权，当同一个HTML元素被不止一个样式定义时，会优先采用内联样式。</p>
<h3 id="css规则由两个主要的部分构成选择器以及一条或多条声明">CSS规则由两个主要的部分构成：选择器，以及一条或多条声明。</h3>
<ol>
<li>选择器：通常是你需要改变样式的HTML元素。常用的选择器有标签选择器、类（class）选择器、id选择器、属性选择器。</li>
<li>声明：每条声明由一个属性和一个值组成。
<ul>
<li>属性：是你希望设置的样式属性。每个属性有一个值。属性和值被冒号分开。</li>
</ul>
</li>
</ol>
<p>下面的示意图更清晰的展示了CSS语法的构成部分：<br>
<img src="https://mxzw.github.io//post-images/1587086173341.BMP" alt="" loading="lazy"></p>
<h3 id="插入样式表">插入样式表</h3>
<p>当读到一个样式表时，浏览器会根据它来格式化HTML文档。插入样式表的方法有三种：</p>
<ol>
<li>外部样式表：指将在外部编辑好的.css文件引入到当前HTML文档中。每个页面使用＜link＞标签来链接到外部的样式表。<br>
注：＜link＞标签是空标签，它仅包含属性，并且它只存在于head部分，且能出现任意次数。<br>
link元素的常用属性有：
<ul>
<li>href：规定被链接文档的位置</li>
<li>rel：规定当前文档与被链接文档的关系</li>
<li>type：规定被链接文档的类型</li>
</ul>
</li>
<li>内部样式表：当单个文档需要特殊的样式时，就应该使用内部样式表。可以使用＜style＞标签来在文档＜head＞标签中定义内部样式表。且＜style＞标签有一个必需的属性<strong>type</strong>，它规定了样式表的类型。</li>
<li>内联样式：由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。要使用内联样式，需要在相关的标签内使用样式（style）属性，（注：不是style标签，而是style属性），style属性可以包含所有CSS属性。例如前面提到过的在＜font＞标签中改变字体的属性。</li>
</ol>
<p>注：当这些样式同时存在时，且针对同一个标签时，谁离该标签近就采用谁，简而言之，谁在最后就谁，后面会把前面重复的样式覆盖掉。</p>
<h3 id="css常用选择器">CSS常用选择器</h3>
<ol>
<li>标签选择器：针对某一种标签整体样式的设计,直接用标签名来表示</li>
<li>类（class）选择器：针对某一类样式的设计，用 <b>&quot;.+类名&quot;</b>来表示</li>
<li>id选择器：针对某一个id样式的设计，用<b>&quot;#+id&quot;</b>名来表示</li>
<li>属性选择器：针对某个标签中属性样式的设计，用<b>&quot;[属性名]&quot;</b>来表示</li>
</ol>
<p>其中：在前三种选择器中，优先级的顺序是：id＞类＞标签，举个例子就是如果id选择器的优先级是100的话，类选择器就是10，标签选择器的优先级就是1。<br>
<font style="color:red;">示例代码如下：</font><br>
①HTML文档部分：</p>
<pre><code>    &lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;UTF-8&quot;&gt;
		&lt;title&gt;css的练习&lt;/title&gt;
		&lt;!--外联样式：针对整个项目样式的设计 --&gt;
		&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt;
		&lt;!--内嵌样式：针对当前网页样式的设计--&gt;
		&lt;!--
		&lt;style type=&quot;text/css&quot;&gt;  
			p{
				font-size: 20px;
				color: red;
				font-weight: bold;
			}
		&lt;/style&gt;
       	--&gt;
		&lt;!-- style标签  此处是定义了p标签 的样式  20px、字体为红色  加粗 --&gt;
		&lt;!--当内嵌样式和外联样式共同存在时，谁离设计的样式最近就用谁，简而言之 
			谁在最后就用谁，后面的会把前面的覆盖掉。
		--&gt;
	&lt;/head&gt;
	&lt;body&gt; 
		&lt;!--行内样式：针对某一行样式的设计    class 表示对其分类   --&gt;
        &lt;p&gt;哈哈哈哈哈&lt;/p&gt;
		&lt;p class=&quot;TSYD&quot;&gt;朴宝英&lt;/p&gt;
		&lt;p class=&quot;TSYD TV&quot;&gt;朴信惠&lt;/p&gt;
		&lt;p class=&quot;TSYD TV&quot; id=&quot;zw&quot;&gt;谭松韵&lt;/p&gt;
		&lt;p class=&quot;TSYD TV&quot;&gt;杨紫&lt;/p&gt;
		&lt;p style=&quot;font-size: 15px; color: green;&quot;&gt;刘昊然&lt;/p&gt;
		&lt;p class=&quot;BYXH&quot;&gt;就哦哦卡萨丁&lt;/p&gt;
		&lt;p class=&quot;BYXH&quot;&gt;大&lt;/p&gt;
		&lt;p class=&quot;BYXH&quot;&gt;啊我店铺&lt;/p&gt; 
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>②外部CSS样式（style.css）：</p>
<pre><code>    
/* 标签选择器：针对某一种标签整体样式的设计*/
p{
	font-size: 20px;
	color: red;
	font-weight: bold;
	font-style: italic;
}

/*对类的设计 用。来表示*/
/*类选择器-- 针对某一类样式的设计*/
.TSYD{
	text-decoration: underline;
}

.BYXH{
	font-family: &quot;宋体&quot;;
}
.TV{
	background-color: azure;
}

/*id 选择器： 针对某一个id样式的设计*/
#zw{
	/*   border 为边框的意思
	border-top: solid;
	border-top-width: 3px;
	border: dashed 2px red;
    */
	border-top: solid 3px yellow;
	border-bottom: dashed 5px black;
	border-left: solid 4px red;
	border-right: dashed 6px green;
}

/*优先级  id 100 class 10  标签  1*/
</code></pre>
<p>代码运行效果如下图：<br>
<img src="https://mxzw.github.io//post-images/1587092322700.BMP" alt="" loading="lazy"></p>
<h1 id="二-超链接的状态">二、超链接的状态</h1>
<p>前面以及学过的用＜a＞标签来表示超链接，在学习过CSS后，本次将采用CSS样式表来显示控制超链接的状态。<br>
所谓的超链接状态：就是类似于鼠标悬停在链接上方的样式或是鼠标点击在链接上方时的样式之类的状态；具体如下：</p>
<ul>
<li>link：普通的、未被访问的链接样式</li>
<li>visited：已被访问的链接样式</li>
<li>hover：鼠标悬停链接上方的样式</li>
<li>active：鼠标点击链接时的样式</li>
</ul>
<p>css定义超链接是有先后顺序的。否则，在某些浏览器里面有可能会出现某个样式不能起作用的bug。不能显示出想要的效果。CSS定义超链接的顺序是：L-V-H-A。<br>
<font style="color:red;">示例代码如下：</font><br>
①HTML文档部分：</p>
<pre><code>    &lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;UTF-8&quot;&gt;
		&lt;title&gt;超链接的状态&lt;/title&gt;
		&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;zw-10超链接的状态.css&quot;/&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;a href=&quot;index.html&quot; target=&quot;_blank&quot;&gt;
			超链接状态
		&lt;/a&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>②外部CSS样式（style.css）：</p>
<pre><code>/*link 表示普通的、未被访问的链接样式     
 *表示只要你进入过该网站，那么link中的内容不会实现*/
a:link{
	color: red;
	font-size: 20px;
	text-decoration: none;
}

/*visited 用户已访问的链接样式*/
a:visited{
	color: skyblue;
}

/*hover 鼠标指针位于链接上方样式*/
a:hover{
	color: green;
	text-decoration: underline;
}

/*active 链接被点击时的时刻样式*/
a:active{
	color: blue;
}
</code></pre>
<p>效果如下：</p>
<table>
    <tr>
        <td><img src="https://raw.githubusercontent.com/mxzw/Gridea_photos/master/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/%E6%9C%AA%E7%82%B9%E5%87%BB%E5%92%8C%E6%82%AC%E5%81%9C%E7%8A%B6%E6%80%81.BMP"/></td>
        <td><img src="https://raw.githubusercontent.com/mxzw/Gridea_photos/master/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/%E6%82%AC%E5%81%9C%E7%8A%B6%E6%80%81.BMP"/></td>
        <td><img src="https://raw.githubusercontent.com/mxzw/Gridea_photos/master/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/%E7%82%B9%E5%87%BB%E7%8A%B6%E6%80%81.BMP"/></td>
    </tr>
    <tr align="center">
        <td >鼠标未悬停和点击时</td>
        <td>鼠标悬停时</td>
        <td>鼠标点击时</td>
    </tr>
</table>
<p>本文的部分内容参考来源于<a href="https://www.w3school.com.cn/h.asp">W3 school</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML学习日记（三）——表格、表单]]></title>
        <id>https://mxzw.github.io/post/html-xue-xi-ri-ji-san-biao-ge-biao-dan/</id>
        <link href="https://mxzw.github.io/post/html-xue-xi-ri-ji-san-biao-ge-biao-dan/">
        </link>
        <updated>2020-04-16T00:18:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-表格">一、表格</h1>
<p>表格由＜table＞标签来定义。每个表格的若干行由＜tr＞（table row）标签来定义，每行中所拥有的表格数据或是有几列由＜td＞（table data）标签来定义，＜td＞中可以包含的内容有：文本、图片、列表、段落、表单、水平线、表格等。</p>
<ol>
<li>table的常用属性：
<ul>
<li>border：边框</li>
<li>width：宽度</li>
<li>height：高度</li>
<li>cellspacing：单元格之间的距离</li>
<li>cellpadding：单元格中文本与边框的距离</li>
<li>bgcolor：背景颜色</li>
<li>background：背景图</li>
<li>align：表格相对于网页的水平对齐</li>
</ul>
</li>
<li>tr的常用属性：
<ul>
<li>bgcolor：背景颜色</li>
<li>align：水平对齐</li>
<li>valign：垂直对齐</li>
<li>height：高度</li>
</ul>
</li>
<li>td的常用属性：
<ul>
<li>bgcolor：背景颜色</li>
<li>background：背景图</li>
<li>align：水平对齐</li>
<li>valign：垂直对齐</li>
<li>width：宽度</li>
<li>colspan：横向合并单元格</li>
<li>rowspan：纵向合并单元格</li>
</ul>
</li>
<li>常用的表格标签：
<ul>
<li>＜caption＞：定义表格标题</li>
<li>＜th＞：定义表格的表头</li>
<li>＜thead＞：定义表格的页眉</li>
<li>＜tfoot＞：定义表格的页脚</li>
<li>＜tbody＞：定义表格的主体</li>
</ul>
</li>
<li>其余：
<ul>
<li>空单元格：用&amp;nbsp；来表示没有内容的单元格</li>
<li>align属性：align只是水平对齐而已，而align=“center”则表示（内容）水平居中对齐。</li>
</ul>
</li>
</ol>
<p><font color="red">示例代码如下：</font></p>
<pre><code>  &lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
  	&lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;!--表明使用UTF-8来编码--&gt;
  	&lt;title&gt;
  		表格的练习  &lt;!--表示网页的标题--&gt;
  	&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  	&lt;table border=&quot;1px&quot; width=&quot;800px&quot; height=&quot;600px&quot;
  		cellspacing=&quot;0px&quot; cellpadding=&quot;20px&quot; bgcolor=&quot;aqua&quot;
  		background=&quot;&quot; align=&quot;center&quot;&gt;
  		&lt;tr bgcolor=&quot;#A9A9A9&quot; align=&quot;center&quot; height=&quot;50px&quot;&gt;
  			&lt;th&gt;表头1&lt;/th&gt;
  			&lt;th&gt;表头2&lt;/th&gt;
  			&lt;th&gt;表头3&lt;/th&gt;
  			&lt;th&gt;表头4&lt;/th&gt;
  		&lt;/tr&gt;
  		&lt;tr align=&quot;right&quot; valign=&quot;bottom&quot; height=&quot;200px&quot;&gt;
  			&lt;td width=&quot;100px&quot;&gt;21&lt;/td&gt;
  			&lt;td	bgcolor=&quot;red&quot; background=&quot;&quot; align=&quot;left&quot; valign=&quot;top&quot;
  				width=&quot;300px&quot; style=&quot;color: blue;&quot;&gt;
  				22 
  				&lt;!--背景颜色为红色，无背景图片，内容相对于网页水平向左对齐
  					内容相对于表格顶端垂直对齐，宽度为300像素，字体颜色为蓝色
  				--&gt;
  			&lt;/td&gt;
  			&lt;td width=&quot;100px&quot;&gt;23&lt;/td&gt;
  			&lt;td rowspan=&quot;2&quot;&gt;34&lt;/td&gt; &lt;!--&gt;纵向合并单元格  
  							从当前单元格开始向下两个单元格合并&lt;/!--&gt;
  		&lt;/tr&gt;
  		&lt;tr height=&quot;350px&quot;&gt;
  			&lt;td colspan=&quot;3&quot;&gt;31&lt;/td&gt;
  			&lt;!--&gt;横向合并单元格
  				从当前单元格开始向右3个单元格合并
  			&lt;/!--&gt;
  		&lt;/tr&gt;
  	&lt;/table&gt;
  	&lt;!--   描述：border 表格的边框
      		cellspacing  单元格与单元格之间的距离
      		cellpadding  单元格内部填充的距离
      		align=&quot;center&quot; 表示表格水平居中对齐 不是内容居中操作   align 表示水平对齐方式
      		valign 表示垂直对齐方式
      		更改单元格的宽度--会更改整列的单元格宽度
      		单元格合并时 是 从左到右合并  从上到下合并
      		colspan 横向合并单元格
      		rowspan 纵向合并单元格
      --&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>效果如下：<br>
<img src="https://mxzw.github.io//post-images/1587001457823.BMP" alt="" loading="lazy"></p>
<h1 id="二-表单">二、表单</h1>
<p>HTML表单由＜form＞标签来定义，HTML表单用于收集用户的输入。<br>
HTML表单包含表单元素，所谓的表单元素指的是不同类型的input元素、复选框、单选按钮、提交按钮等。</p>
<h3 id="input元素是最重要的表单元素它随着type属性有很多不同的形态">＜input＞元素：是<strong>最重要的</strong>表单元素，它随着type属性有很多不同的形态。</h3>
<ul>
<li>type=“text”：指在表单中加入一个<strong>单行文本框</strong></li>
<li>type=“password”：指在表单中加入一个<strong>密码文本框</strong></li>
<li>type=“radio”：指在表单中加入<strong>单选按钮</strong></li>
<li>type=“checkbox”：<strong>复选框</strong></li>
<li>type=“submit”：<strong>提交按钮</strong>，向服务器端发送当前表单中的数据（name、id、value）</li>
<li>type=“reset”：<strong>重置按钮</strong>，将表单中的控件全部设为默认值</li>
<li>type=“button”：<strong>普通 按钮</strong>，本身没有任何作用，但可配合脚本语言实现任何效果</li>
</ul>
<h3 id="form标签的属性">＜form＞标签的属性</h3>
<ol>
<li>name：表单的名字</li>
<li>action：用于处理数据的程序路径，当提交表单时会执行此程序。如果省略该属性，则action会设置为当前页面</li>
<li>method：规定在提交表单时所用的HTTP方法（指get或post）
<ul>
<li>get：（默认方法）获取。适合于少量数据的提交。get方法的弊端是表单数据在页面地址栏是可见的，不安全。它是先将数据发送到url中，再提交到后台服务器中，安全性低下。<br>
（URL：Uniform Resource Locator----统一资源定位）</li>
<li>post：提交。适合数据量大的提交。当表单在更新数据或包含敏感信息时（密码），安全系数高。它是先将数据转化成标准数据流，再提交到服务器，安全性高。</li>
</ul>
</li>
</ol>
<h3 id="input标签的常用属性">＜input＞标签的常用属性</h3>
<ul>
<li>name：控件名</li>
<li>value：文本框内默认值、内置值</li>
<li>width：文本框宽度</li>
<li>maxlength：允许输入的最多字符数</li>
<li>placehold：占位符（提示语）</li>
<li>size：文本框大小</li>
<li>type：类型</li>
<li>checked：设置为默认选中<br>
<font color="red">注：若为一组单选按钮，则一组单选按钮的name值要保持一致。</font></li>
</ul>
<h3 id="form标签的其他元素">＜form＞标签的其他元素</h3>
<ol>
<li>
<p>多行文本框<br>
多行文本框用＜textarea＞＜/textarea＞标签来表示。<br>
它的常用属性有：</p>
<ul>
<li>name：控件名</li>
<li>rows：文本框的行数</li>
<li>cols：文本框的宽度</li>
<li>wrap：文字换行方式，默认为文字到末尾自动换行；如果设置为off，则不会自动换行。</li>
<li>resize：重置大小（通常是在css中设置的）</li>
</ul>
</li>
<li>
<p>列表框控件<br>
用＜select＞＜/select＞来表示一个列表框，且用＜option＞＜/option＞来表示一个列表中的选项。<br>
①select属性：</p>
<ul>
<li>name：控件名</li>
<li>size：显示行数</li>
<li>multiple：允许多选</li>
</ul>
<p>②option属性：</p>
<ul>
<li>value：内置值</li>
<li>selected：默认选中</li>
</ul>
</li>
</ol>
<p><font color="red">示例代码如下：</font></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;!--表明使用UTF-8来编码--&gt;
		&lt;title&gt;
			表单的练习  &lt;!--表示网页的标题--&gt;
		&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;form name=&quot;regist&quot; action=&quot;&quot; method=&quot;post&quot;&gt;
			账号：&lt;input type=&quot;text&quot; name=&quot;userna&quot; id=&quot;username&quot; value=&quot;&quot;
				placeholder=&quot;请输入账号&quot; maxlength=&quot;10&quot; size=&quot;25&quot;/&gt;
				&lt;br /&gt;&lt;br /&gt;
			密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; value=&quot;&quot;
				placeholder=&quot;请输入密码&quot; maxlength=&quot;6&quot; size=&quot;25&quot; /&gt;
				&lt;br /&gt;&lt;br /&gt;
			性别：&lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;gender&quot; value=&quot;man&quot; /&gt; 男
				&lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;girl&quot; value=&quot;girl&quot; checked=&quot;checked&quot;/&gt;女
				&lt;br /&gt;&lt;br /&gt;&lt;!--这里的value值会被默认存入后台数据库中--&gt;
			爱好：&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; id=&quot;smoking&quot; value=&quot;smoking&quot;/&gt; 抽烟
				&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; id=&quot;drinking&quot; value=&quot;drinking&quot;/&gt; 喝酒
				&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; id=&quot;perming&quot; value=&quot;perming&quot;
					checked=&quot;checked&quot;/&gt; 烫头
				&lt;br /&gt;&lt;br /&gt;
			简介：	&lt;textarea name=&quot;express&quot; rows=&quot;5&quot; cols=&quot;25&quot;&gt;&lt;/textarea&gt;
			&lt;br /&gt;&lt;br /&gt;
			游戏：&lt;select name=&quot;game&quot; id=&quot;game&quot; size=&quot;7&quot; multiple=&quot;multiple&quot;&gt;
				&lt;!--size:表示显示的行数；multiple：表示可以多选--&gt;
				&lt;option value=&quot;LOL&quot;&gt;LOL&lt;/option&gt;
				&lt;option value=&quot;BBQ&quot;&gt;BBQ&lt;/option&gt;
				&lt;option value=&quot;CF&quot;&gt;CF&lt;/option&gt;
				&lt;option value=&quot;DOTA&quot;&gt;DOTA&lt;/option&gt;
				&lt;option value=&quot;CSGO&quot;&gt;CSGO&lt;/option&gt;
				&lt;option value=&quot;DBDN&quot;&gt;DBDN&lt;/option&gt;
				&lt;option value=&quot;DL&quot; selected=&quot;selected&quot;&gt;DL&lt;/option&gt;
				&lt;!--selected表示默认选中--&gt;
			&lt;/select&gt;
			&lt;br /&gt;&lt;br /&gt;
			&lt;input type=&quot;submit&quot; name=&quot;smit&quot; id=&quot;smit&quot; value=&quot;注册&quot; /&gt;
			&lt;input type=&quot;reset&quot; name=&quot;smit&quot; id=&quot;smit&quot; value=&quot;恢复默认值&quot; /&gt;
		&lt;/form&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>效果如下：<br>
<img src="https://mxzw.github.io//post-images/1587036208171.BMP" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML学习日记（二）——列表、图片插入、超链接]]></title>
        <id>https://mxzw.github.io/post/html-xue-xi-ri-ji-er-lie-biao-tu-pian-cha-ru-chao-lian-jie/</id>
        <link href="https://mxzw.github.io/post/html-xue-xi-ri-ji-er-lie-biao-tu-pian-cha-ru-chao-lian-jie/">
        </link>
        <updated>2020-04-15T09:16:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-列表">一、列表</h1>
<ol>
<li><strong>有序列表</strong><br>
在HTML中，表示有序列表的标签是＜ol＞＜/ol＞（ordered list），而表示列表项的标签是＜li＞＜/li＞（list）。常用HTML属性为type，可赋值的类型有：1(阿拉伯数字)、A(大写字母)、a(小写字母)、Ⅰ(大写罗马数字)、i(小写罗马数字)。 <table>
         <tr>
                 <td><img src="https://raw.githubusercontent.com/mxzw/Gridea_photos/master/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%E8%AF%AD%E6%B3%95.BMP" /></td>
                 <td><img src="https://raw.githubusercontent.com/mxzw/Gridea_photos/master/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%E5%B1%95%E7%A4%BA.BMP" /></td>
         </tr>
 </table>
</li>
<li><strong>无序列表</strong><br>
表示无序列表的HTML标签是＜ul＞＜/ul＞（unordered list），表示列表项的HTML标签依旧是＜li＞＜/li＞（list）。常用的HTML属性为type，可赋值类型有:circle(空圆)、square(正方形)、disc(实圆)。 <table>
         <tr>
                 <td><img src="https://raw.githubusercontent.com/mxzw/Gridea_photos/master/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%E8%AF%AD%E6%B3%95.BMP" /></td>
                 <td><img src="https://raw.githubusercontent.com/mxzw/Gridea_photos/master/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%E5%B1%95%E7%A4%BA.BMP" /></td>
         </tr>
 </table>
</li>
<li><strong>无序列表和有序列表的嵌套</strong><br>
两种列表的嵌套实际上就是在要嵌套的列表的列表项中，将里面的内容替换为另一种列表而已，类似于换元法。 <table>
         <tr>
                 <td><img src="https://raw.githubusercontent.com/mxzw/Gridea_photos/master/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/%E5%88%97%E8%A1%A8%E5%B5%8C%E5%A5%97%E8%AF%AD%E6%B3%95.BMP" /></td>
                 <td><img src="https://raw.githubusercontent.com/mxzw/Gridea_photos/master/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/%E5%88%97%E8%A1%A8%E5%B5%8C%E5%A5%97%E5%B1%95%E7%A4%BA.BMP" /></td>
         </tr>
 </table>
</li>
</ol>
<h1 id="二-图片的插入">二、图片的插入</h1>
<p>＜img /＞标签表示向网页中插入图片，需要注意的是从技术上来说，＜img /＞标签并不会在网页中插入图像，而是从网页上链接图像，＜ing /＞标签创建的是被引用图像的占位空间。<br>
＜img /＞标签有两个必须的HTML属性：src属性和alt属性。</p>
<ul>
<li>src属性：用来规定显示图像的链接（或是图片的路径），通常为src=“xxx”，xxx为图片所在的链接（路径）。</li>
<li>alt属性：用来规定图像的替代文本，简单来说就是图片加载异常时的提示语，通常为alt=“xxx”，xxx为所要提示的内容。</li>
</ul>
<p>＜img /＞标签除了以上两个必选打的属性外，其他常用的可选的属性：</p>
<ul>
<li>
<p>align：规定如何根据周围文本来跑排列图像。</p>
</li>
<li>
<p>height：定义图像的高度。</p>
</li>
<li>
<p>width：设置图像的宽度。</p>
</li>
<li>
<p>title：设置图片的标题。</p>
<table>
        <tr>
                <td><img src="https://raw.githubusercontent.com/mxzw/Gridea_photos/master/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/%E5%9B%BE%E7%89%87%E6%8F%92%E5%85%A5%E8%AF%AD%E6%B3%95.BMP" /></td>
                <td><img src="https://raw.githubusercontent.com/mxzw/Gridea_photos/master/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/%E5%9B%BE%E7%89%87%E6%8F%92%E5%85%A5%E5%B1%95%E7%A4%BA.BMP" /></td>
        </tr>
</table>
</li>
</ul>
<h1 id="三-超链接">三、超链接</h1>
<p>用＜a＞标签来表示超链接。（anchor）<br>
＜a＞标签中最重要的属性示href属性，它和插入图片标签＜img /＞中的src属性一样，它指示链接的目标网址。常用的HTML属性为：target，可赋值的类型有：_self（在本身页面跳转）、_blank（在新页面跳转）。</p>
  <table>
            <tr>
                    <td><img src="https://raw.githubusercontent.com/mxzw/Gridea_photos/master/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/%E8%B6%85%E9%93%BE%E6%8E%A5%E8%AF%AD%E6%B3%95.BMP" /></td>
                    <td><img src="https://raw.githubusercontent.com/mxzw/Gridea_photos/master/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/%E8%B6%85%E9%93%BE%E6%8E%A5%E5%B1%95%E7%A4%BA.BMP" /></td>
                    <td><img src="https://raw.githubusercontent.com/mxzw/Gridea_photos/master/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/%E8%B6%85%E9%93%BE%E6%8E%A5%E5%B1%95%E7%A4%BA2.BMP" /></td>
            </tr>
    </table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML学习日记（一）——文字的基本格式]]></title>
        <id>https://mxzw.github.io/post/html-xue-xi-ri-ji-yi-wen-zi-de-ji-ben-ge-shi/</id>
        <link href="https://mxzw.github.io/post/html-xue-xi-ri-ji-yi-wen-zi-de-ji-ben-ge-shi/">
        </link>
        <updated>2020-04-14T06:16:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-什么是html">一、什么是HTML</h1>
<p>HTML是用来描述网页的一种语言。</p>
<ul>
<li>HTML是一种超文本标记语言（Hyper Text Markup Language)</li>
<li>不是编程语言，是一种标记语言</li>
<li>标记语言是一套标记标签</li>
<li>HTML使用标记标签来描述网页</li>
</ul>
<h1 id="二-html标签">二、HTML标签</h1>
<ul>
<li>HTML标签是由一对尖括号包围起来的关键词，如：&lt;...&gt;，其中...代表着相应的关键词。</li>
<li>HTML标签是一般都是成对出现的，如：＜b＞和＜/b＞。</li>
<li>标签对中第一个标签为开始标签，第二个标签为结束标签。</li>
</ul>
<h1 id="三-html文档">三、HTML文档</h1>
<p>一个HTML文档就相相当于一个网页。HTML文档包含着HTML标签和纯文本（也就是网页的内容）。web浏览器的作用就是读取HTML文档并以网页的形式显示它们，并且不会显示HTML标签，而是用标签来解释页面的内容。</p>
<table>
    <tr>
            <td><img src="https://raw.githubusercontent.com/mxzw/Gridea_photos/master/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%96%87%E5%AD%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F/HTML%E6%96%87%E6%A1%A3%E8%AF%AD%E6%B3%95.BMP"/></td>
            <td><img src="https://raw.githubusercontent.com/mxzw/Gridea_photos/master/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%96%87%E5%AD%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F/HTMl%E6%96%87%E6%A1%A3%E5%B1%95%E7%A4%BA.BMP"></td>
    </tr>
</table>
其中，＜html＞和＜/html＞之间的文本用来描述网页；＜head＞和＜/head＞间的文本用来定义文档的头部，描述了文档的各种属性和信息，包括文档的标题、在web中的位置以及和其他文档的关系等；而＜body＞和＜/body＞间的纯文本是web中可见的页面内容。  
<h1 id="四-html文字的基本格式">四、HTML文字的基本格式</h1>
<p>下面，首先展示HTML在文字格式方面的语法。</p>
<ol>
<li>标题<br>
在HTML中标题是通过＜h1＞＜/h1＞<sub>＜h6＞＜/h6＞等标签来表示一级标题</sub>六级标题的（自动加粗，自动换行，且与上下文间有隔行）。</li>
<li>段落、换行<br>
HTML段落是通过＜p＞＜/p＞标签来表示的（自动换行，且与上下文间有隔行）。<br>
而换行的标签为＜br /＞（blankrow），它是只有一对尖括号组成的标签。</li>
<li>加粗、倾斜、下划线、删除线
<ul>
<li>加粗（Bold）：＜b＞＜/b＞</li>
<li>倾斜（Italic）：＜i＞＜/i＞</li>
<li>下划线（Underline）：＜u＞＜/u＞</li>
<li>删除线（strike）：＜s＞＜/s＞</li>
</ul>
</li>
<li>上角标、下角标
<ul>
<li>上角标（super script）：＜sup＞＜/sup＞</li>
<li>下角标（sub script）：＜sub＞＜/sub＞</li>
</ul>
</li>
<li>设置字体格式<br>
设置字体格式用＜font＞＜/font＞标签来实现，但具体的内容，如：字体大小、颜色等等，是由HTML属性来实现的，HTML标签可以拥有属性，属性提供了有关HTML元素（标签）的更多的信息。属性总是以名称/值对的形式出现，比如：name=&quot;value&quot;；且属性总是在HTML元素的开始标签中直接规定的。<br>
除了HTML属性可以具体表示HTML标签中的信息外，css语言也可以实现此类功能。
<h3 id="css简介">CSS简介</h3>
<pre><code>CSS指层叠样式表（Cascading Style Sheets），是一种用来表现HTML或XML等文件样式的计算机语言。
+ 可以静态修饰网页。
+ 可以配合各种脚本对网页各元素进行格式化。
+ 样式定义可以如何显示HTML元素（标签）。
+ 对HTML元素的排版进行像素级精确控制，支持几乎所有的字体字体样式。
+ 拥有对网页对象和模型样式编辑的能力。    
</code></pre>
<h3 id="font标签的css样式属性">＜font＞标签的css样式属性</h3>
<pre><code>不建议用HTML属性对其属性进行设置，使用css样式来替代是更好的选择。
+ font-size：文字大小
+ color：字体颜色
+ font-family：字体系列---（指宋体、楷体之类的字体类型）
+ font-weight：文字粗细
+ font-style：文字类型---（指加粗、倾斜之类的）
+ text-decoration：文本修饰
（以上为＜font＞标签常用的css样式属性，下方为css其他常用标签的样式属性）
+ border：边框
+ boder-top：上边框（下边框同理，将top改为bottom即可）
+ border-bottom-color：下边框颜色
+ background-color：背景颜色
+ background：背景图
</code></pre>
</li>
<li>注释<br>
HTML语言的注释标签是＜!--xxxx --＞，表示对xxx进行注释，不在网页中显示出来，写注释一般是为了使自己或其他人在阅读该代码时，更加清晰的明白你的想法，明白你写的代码，多写注释是很好的习惯。</li>
<li><font style="color:red;font-weight:bold;">以上代码实现效果如下图：</font><table>
 <tr>
         <td><img src="https://raw.githubusercontent.com/mxzw/Gridea_photos/master/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%96%87%E5%AD%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F/%E6%96%87%E5%AD%97%E4%BB%A3%E7%A0%81%E8%AF%AD%E6%B3%95.BMP"/></td>
         <td><img src="https://raw.githubusercontent.com/mxzw/Gridea_photos/master/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%96%87%E5%AD%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F/%E6%96%87%E5%AD%97%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA.BMP"></td>
 </tr>
</li>
</ol>
</table>
]]></content>
    </entry>
</feed>